Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB]

 

 

 

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её

 

нужно прервать.

 

 

 

Вы как инженер поддержки решили произвести данную операцию:

 

- напишите список операций, которые вы будете производить для остановки запроса пользователя

 

 

 

Определим текущую операцию командой:

 

       db.currentOp()

 

Завершим операцию по opid

 

       db.killOp()

 

 

Для того чтобы ограничить запрос по времени можно использовать метод maxTimeMS()

 

 

 

## Задача 2

 

 

 

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

 

 

 

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL.

 

Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.

 

 

При масштабировании сервиса до N реплик вы увидели, что:

 

- сначала рост отношения записанных значений к истекшим

 

- Redis блокирует операции записи

 

 

 

Как вы думаете, в чем может быть проблема?

 

 

 

Проблема может заключаться в том, что срок действия ключей реплик не истекает, вместо этого они ожидают, истечения срока действия ключей мастеров. Когда на мастере истекает срок действия ключа, он синтезирует команду DEL, которая передается на все реплики. В какой-то момент число команд на запись и удаление достигает предела и новые запросы начинают блокироваться. Так же возможной причиной большого количества ключей с истёкшим временем может быть прямое указание времени истечения в unix формате (EXPIREAT), а не TTL ключа в секундах. Redis не успевает очищать базу от истекших кличей, как вариант решения увеличить ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP.

 

 

## Задача 3

 

 

 

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors]

 

 

 

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,

 

пользователи начали жаловаться на ошибки вида:

 

```python

 

InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '

 

```

 

 

 

Как вы думаете, почему это начало происходить и как локализовать проблему?

 

Какие пути решения данной проблемы вы можете предложить?

 

 

 

В документации описаны 3 распространенные варианта проблемы:

 

- Во время запроса - Увеличить значение переменной net_read_timeout >= 30 sec

 

- Во время первоначального подключения - увеличить значение переменной connect_timeout >= 10 sec + мониторинг SHOW GLOBAL STATUS LIKE "Aborted_connects".

 

- Если проблема не подпадает под 2 вышестоящих пункта - следует проверить значения BLOB, они могут быть больше max_allowed_packet

 

 

 

 

 

## Задача 4

 

 

 

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors]

 

 

 

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.

 

 

 

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

 

 

 

`postmaster invoked oom-killer`

 

 

 

Как вы думаете, что происходит?

 

Проблема в нехватке памяти, ядро Linux реализует перераспределение памяти, потребность в памяти для PostgreSQL или другого процесса приводит к тому, что системе не хватает виртуальной памяти и ядро высвобождает его завершая процесс PostgresSQL.

 

Как бы вы решили данную проблему?

 

Если памяти не хватает по вине самого PostgresSQL, эту проблему можно решить, изменив конфигурацию сервера. В некоторых случаях может помочь уменьшение конфигурационных параметров, связанных с памятью, а именно shared_buffers и work_mem. В других случаях проблема может возникать, потому что разрешено слишком много подключений к самому серверу баз данных. Чаще всего в такой ситуации стоит уменьшить число подключений max_connections и организовать внешний пул соединений. Один из способов избежать этой проблемы — запускать PostgreSQL на хосте, где другие процессы не будут приводить к нехватке памяти. Исключить влияние других процессов. Если памяти мало - увеличить пространство подкачки операционной системы. OOM-Killer вызывается только в случае, когда физическая память и пространство подкачки исчерпаны.
